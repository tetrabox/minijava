/*
 * generated by Xtext 2.25.0
 */
package org.tetrabox.minijava.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.tetrabox.minijava.model.miniJava.And;
import org.tetrabox.minijava.model.miniJava.ArrayAccess;
import org.tetrabox.minijava.model.miniJava.ArrayLength;
import org.tetrabox.minijava.model.miniJava.ArrayTypeRef;
import org.tetrabox.minijava.model.miniJava.Assignment;
import org.tetrabox.minijava.model.miniJava.Block;
import org.tetrabox.minijava.model.miniJava.BoolConstant;
import org.tetrabox.minijava.model.miniJava.BooleanTypeRef;
import org.tetrabox.minijava.model.miniJava.ClassRef;
import org.tetrabox.minijava.model.miniJava.Division;
import org.tetrabox.minijava.model.miniJava.Equality;
import org.tetrabox.minijava.model.miniJava.Field;
import org.tetrabox.minijava.model.miniJava.FieldAccess;
import org.tetrabox.minijava.model.miniJava.ForStatement;
import org.tetrabox.minijava.model.miniJava.IfStatement;
import org.tetrabox.minijava.model.miniJava.Import;
import org.tetrabox.minijava.model.miniJava.Inequality;
import org.tetrabox.minijava.model.miniJava.Inferior;
import org.tetrabox.minijava.model.miniJava.InferiorOrEqual;
import org.tetrabox.minijava.model.miniJava.IntConstant;
import org.tetrabox.minijava.model.miniJava.IntegerTypeRef;
import org.tetrabox.minijava.model.miniJava.Interface;
import org.tetrabox.minijava.model.miniJava.Method;
import org.tetrabox.minijava.model.miniJava.MethodCall;
import org.tetrabox.minijava.model.miniJava.MiniJavaPackage;
import org.tetrabox.minijava.model.miniJava.Minus;
import org.tetrabox.minijava.model.miniJava.Multiplication;
import org.tetrabox.minijava.model.miniJava.Neg;
import org.tetrabox.minijava.model.miniJava.NewArray;
import org.tetrabox.minijava.model.miniJava.NewObject;
import org.tetrabox.minijava.model.miniJava.Not;
import org.tetrabox.minijava.model.miniJava.Null;
import org.tetrabox.minijava.model.miniJava.Or;
import org.tetrabox.minijava.model.miniJava.Plus;
import org.tetrabox.minijava.model.miniJava.PrintStatement;
import org.tetrabox.minijava.model.miniJava.Program;
import org.tetrabox.minijava.model.miniJava.Return;
import org.tetrabox.minijava.model.miniJava.StringConstant;
import org.tetrabox.minijava.model.miniJava.StringTypeRef;
import org.tetrabox.minijava.model.miniJava.Super;
import org.tetrabox.minijava.model.miniJava.Superior;
import org.tetrabox.minijava.model.miniJava.SuperiorOrEqual;
import org.tetrabox.minijava.model.miniJava.SymbolRef;
import org.tetrabox.minijava.model.miniJava.This;
import org.tetrabox.minijava.model.miniJava.VariableDeclaration;
import org.tetrabox.minijava.model.miniJava.VoidTypeRef;
import org.tetrabox.minijava.model.miniJava.WhileStatement;
import org.tetrabox.minijava.xtext.services.MiniJavaGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractMiniJavaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiniJavaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MiniJavaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MiniJavaPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case MiniJavaPackage.ARRAY_ACCESS:
				sequence_ArrayAccess(context, (ArrayAccess) semanticObject); 
				return; 
			case MiniJavaPackage.ARRAY_LENGTH:
				sequence_ArrayLength(context, (ArrayLength) semanticObject); 
				return; 
			case MiniJavaPackage.ARRAY_TYPE_REF:
				sequence_TypeRef(context, (ArrayTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MiniJavaPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MiniJavaPackage.BOOL_CONSTANT:
				sequence_TerminalExpression(context, (BoolConstant) semanticObject); 
				return; 
			case MiniJavaPackage.BOOLEAN_TYPE_REF:
				sequence_SingleTypeRef(context, (BooleanTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.CLASS:
				sequence_Class(context, (org.tetrabox.minijava.model.miniJava.Class) semanticObject); 
				return; 
			case MiniJavaPackage.CLASS_REF:
				sequence_ClassRef(context, (ClassRef) semanticObject); 
				return; 
			case MiniJavaPackage.DIVISION:
				sequence_MulOrDiv(context, (Division) semanticObject); 
				return; 
			case MiniJavaPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case MiniJavaPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case MiniJavaPackage.FIELD_ACCESS:
				sequence_SelectionExpression(context, (FieldAccess) semanticObject); 
				return; 
			case MiniJavaPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case MiniJavaPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case MiniJavaPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case MiniJavaPackage.INEQUALITY:
				sequence_Equality(context, (Inequality) semanticObject); 
				return; 
			case MiniJavaPackage.INFERIOR:
				sequence_Comparison(context, (Inferior) semanticObject); 
				return; 
			case MiniJavaPackage.INFERIOR_OR_EQUAL:
				sequence_Comparison(context, (InferiorOrEqual) semanticObject); 
				return; 
			case MiniJavaPackage.INT_CONSTANT:
				sequence_TerminalExpression(context, (IntConstant) semanticObject); 
				return; 
			case MiniJavaPackage.INTEGER_TYPE_REF:
				sequence_SingleTypeRef(context, (IntegerTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case MiniJavaPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case MiniJavaPackage.METHOD_CALL:
				sequence_SelectionExpression(context, (MethodCall) semanticObject); 
				return; 
			case MiniJavaPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case MiniJavaPackage.MULTIPLICATION:
				sequence_MulOrDiv(context, (Multiplication) semanticObject); 
				return; 
			case MiniJavaPackage.NEG:
				sequence_Primary(context, (Neg) semanticObject); 
				return; 
			case MiniJavaPackage.NEW_ARRAY:
				sequence_TerminalExpression(context, (NewArray) semanticObject); 
				return; 
			case MiniJavaPackage.NEW_OBJECT:
				sequence_TerminalExpression(context, (NewObject) semanticObject); 
				return; 
			case MiniJavaPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case MiniJavaPackage.NULL:
				sequence_TerminalExpression(context, (Null) semanticObject); 
				return; 
			case MiniJavaPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case MiniJavaPackage.PARAMETER:
				sequence_Parameter(context, (org.tetrabox.minijava.model.miniJava.Parameter) semanticObject); 
				return; 
			case MiniJavaPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case MiniJavaPackage.PRINT_STATEMENT:
				sequence_PrintStatement(context, (PrintStatement) semanticObject); 
				return; 
			case MiniJavaPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MiniJavaPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case MiniJavaPackage.STRING_CONSTANT:
				sequence_TerminalExpression(context, (StringConstant) semanticObject); 
				return; 
			case MiniJavaPackage.STRING_TYPE_REF:
				sequence_SingleTypeRef(context, (StringTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.SUPER:
				sequence_TerminalExpression(context, (Super) semanticObject); 
				return; 
			case MiniJavaPackage.SUPERIOR:
				sequence_Comparison(context, (Superior) semanticObject); 
				return; 
			case MiniJavaPackage.SUPERIOR_OR_EQUAL:
				sequence_Comparison(context, (SuperiorOrEqual) semanticObject); 
				return; 
			case MiniJavaPackage.SYMBOL_REF:
				sequence_TerminalExpression(context, (SymbolRef) semanticObject); 
				return; 
			case MiniJavaPackage.THIS:
				sequence_TerminalExpression(context, (This) semanticObject); 
				return; 
			case MiniJavaPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case MiniJavaPackage.VOID_TYPE_REF:
				sequence_SingleTypeRef(context, (VoidTypeRef) semanticObject); 
				return; 
			case MiniJavaPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assignee returns And
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0_0_0 returns And
	 *     Equality.Inequality_1_0_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns And
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns And
	 *     Comparison.Superior_1_0_2_0 returns And
	 *     Comparison.Inferior_1_0_3_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.Multiplication_1_0_0_0 returns And
	 *     MulOrDiv.Division_1_0_1_0 returns And
	 *     ArrayAccess returns And
	 *     ArrayAccess.ArrayAccess_1_0 returns And
	 *     ArrayLength returns And
	 *     ArrayLength.ArrayLength_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns ArrayAccess
	 *     Expression returns ArrayAccess
	 *     Or returns ArrayAccess
	 *     Or.Or_1_0 returns ArrayAccess
	 *     And returns ArrayAccess
	 *     And.And_1_0 returns ArrayAccess
	 *     Equality returns ArrayAccess
	 *     Equality.Equality_1_0_0_0 returns ArrayAccess
	 *     Equality.Inequality_1_0_1_0 returns ArrayAccess
	 *     Comparison returns ArrayAccess
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns ArrayAccess
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns ArrayAccess
	 *     Comparison.Superior_1_0_2_0 returns ArrayAccess
	 *     Comparison.Inferior_1_0_3_0 returns ArrayAccess
	 *     PlusOrMinus returns ArrayAccess
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayAccess
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayAccess
	 *     MulOrDiv returns ArrayAccess
	 *     MulOrDiv.Multiplication_1_0_0_0 returns ArrayAccess
	 *     MulOrDiv.Division_1_0_1_0 returns ArrayAccess
	 *     ArrayAccess returns ArrayAccess
	 *     ArrayAccess.ArrayAccess_1_0 returns ArrayAccess
	 *     ArrayLength returns ArrayAccess
	 *     ArrayLength.ArrayLength_1_0 returns ArrayAccess
	 *     Primary returns ArrayAccess
	 *
	 * Constraint:
	 *     (object=ArrayAccess_ArrayAccess_1_0 index=Expression)
	 */
	protected void sequence_ArrayAccess(ISerializationContext context, ArrayAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ARRAY_ACCESS__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ARRAY_ACCESS__OBJECT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ARRAY_ACCESS__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ARRAY_ACCESS__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayAccessAccess().getArrayAccessObjectAction_1_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getArrayAccessAccess().getIndexExpressionParserRuleCall_1_2_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns ArrayLength
	 *     Expression returns ArrayLength
	 *     Or returns ArrayLength
	 *     Or.Or_1_0 returns ArrayLength
	 *     And returns ArrayLength
	 *     And.And_1_0 returns ArrayLength
	 *     Equality returns ArrayLength
	 *     Equality.Equality_1_0_0_0 returns ArrayLength
	 *     Equality.Inequality_1_0_1_0 returns ArrayLength
	 *     Comparison returns ArrayLength
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns ArrayLength
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns ArrayLength
	 *     Comparison.Superior_1_0_2_0 returns ArrayLength
	 *     Comparison.Inferior_1_0_3_0 returns ArrayLength
	 *     PlusOrMinus returns ArrayLength
	 *     PlusOrMinus.Plus_1_0_0_0 returns ArrayLength
	 *     PlusOrMinus.Minus_1_0_1_0 returns ArrayLength
	 *     MulOrDiv returns ArrayLength
	 *     MulOrDiv.Multiplication_1_0_0_0 returns ArrayLength
	 *     MulOrDiv.Division_1_0_1_0 returns ArrayLength
	 *     ArrayAccess returns ArrayLength
	 *     ArrayAccess.ArrayAccess_1_0 returns ArrayLength
	 *     ArrayLength returns ArrayLength
	 *     ArrayLength.ArrayLength_1_0 returns ArrayLength
	 *     Primary returns ArrayLength
	 *
	 * Constraint:
	 *     array=ArrayLength_ArrayLength_1_0
	 */
	protected void sequence_ArrayLength(ISerializationContext context, ArrayLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ARRAY_LENGTH__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ARRAY_LENGTH__ARRAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayLengthAccess().getArrayLengthArrayAction_1_0(), semanticObject.getArray());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (assignee=Assignee value=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT__ASSIGNEE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT__ASSIGNEE));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAssigneeAssigneeParserRuleCall_0_0(), semanticObject.getAssignee());
		feeder.accept(grammarAccess.getAssignmentAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *     Statement returns Block
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns ClassRef
	 *     TypeRef.ArrayTypeRef_1_0 returns ClassRef
	 *     SingleTypeRef returns ClassRef
	 *     ClassRef returns ClassRef
	 *
	 * Constraint:
	 *     referencedClass=[TypeDeclaration|QualifiedName]
	 */
	protected void sequence_ClassRef(ISerializationContext context, ClassRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.CLASS_REF__REFERENCED_CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.CLASS_REF__REFERENCED_CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassRefAccess().getReferencedClassTypeDeclarationQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(MiniJavaPackage.Literals.CLASS_REF__REFERENCED_CLASS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns Class
	 *     Class returns Class
	 *     NamedElement returns Class
	 *
	 * Constraint:
	 *     (
	 *         accessLevel=AccessLevel? 
	 *         abstract?='abstract'? 
	 *         name=ID 
	 *         superClass=[Class|QualifiedName]? 
	 *         (implements+=[Interface|QualifiedName] implements+=[Interface|QualifiedName]*)? 
	 *         members+=Member*
	 *     )
	 */
	protected void sequence_Class(ISerializationContext context, org.tetrabox.minijava.model.miniJava.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Inferior
	 *     Expression returns Inferior
	 *     Or returns Inferior
	 *     Or.Or_1_0 returns Inferior
	 *     And returns Inferior
	 *     And.And_1_0 returns Inferior
	 *     Equality returns Inferior
	 *     Equality.Equality_1_0_0_0 returns Inferior
	 *     Equality.Inequality_1_0_1_0 returns Inferior
	 *     Comparison returns Inferior
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Inferior
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Inferior
	 *     Comparison.Superior_1_0_2_0 returns Inferior
	 *     Comparison.Inferior_1_0_3_0 returns Inferior
	 *     PlusOrMinus returns Inferior
	 *     PlusOrMinus.Plus_1_0_0_0 returns Inferior
	 *     PlusOrMinus.Minus_1_0_1_0 returns Inferior
	 *     MulOrDiv returns Inferior
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Inferior
	 *     MulOrDiv.Division_1_0_1_0 returns Inferior
	 *     ArrayAccess returns Inferior
	 *     ArrayAccess.ArrayAccess_1_0 returns Inferior
	 *     ArrayLength returns Inferior
	 *     ArrayLength.ArrayLength_1_0 returns Inferior
	 *     Primary returns Inferior
	 *
	 * Constraint:
	 *     (left=Comparison_Inferior_1_0_3_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Inferior semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.INFERIOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.INFERIOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.INFERIOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.INFERIOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getInferiorLeftAction_1_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns InferiorOrEqual
	 *     Expression returns InferiorOrEqual
	 *     Or returns InferiorOrEqual
	 *     Or.Or_1_0 returns InferiorOrEqual
	 *     And returns InferiorOrEqual
	 *     And.And_1_0 returns InferiorOrEqual
	 *     Equality returns InferiorOrEqual
	 *     Equality.Equality_1_0_0_0 returns InferiorOrEqual
	 *     Equality.Inequality_1_0_1_0 returns InferiorOrEqual
	 *     Comparison returns InferiorOrEqual
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns InferiorOrEqual
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns InferiorOrEqual
	 *     Comparison.Superior_1_0_2_0 returns InferiorOrEqual
	 *     Comparison.Inferior_1_0_3_0 returns InferiorOrEqual
	 *     PlusOrMinus returns InferiorOrEqual
	 *     PlusOrMinus.Plus_1_0_0_0 returns InferiorOrEqual
	 *     PlusOrMinus.Minus_1_0_1_0 returns InferiorOrEqual
	 *     MulOrDiv returns InferiorOrEqual
	 *     MulOrDiv.Multiplication_1_0_0_0 returns InferiorOrEqual
	 *     MulOrDiv.Division_1_0_1_0 returns InferiorOrEqual
	 *     ArrayAccess returns InferiorOrEqual
	 *     ArrayAccess.ArrayAccess_1_0 returns InferiorOrEqual
	 *     ArrayLength returns InferiorOrEqual
	 *     ArrayLength.ArrayLength_1_0 returns InferiorOrEqual
	 *     Primary returns InferiorOrEqual
	 *
	 * Constraint:
	 *     (left=Comparison_InferiorOrEqual_1_0_1_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, InferiorOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.INFERIOR_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.INFERIOR_OR_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.INFERIOR_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.INFERIOR_OR_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getInferiorOrEqualLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Superior
	 *     Expression returns Superior
	 *     Or returns Superior
	 *     Or.Or_1_0 returns Superior
	 *     And returns Superior
	 *     And.And_1_0 returns Superior
	 *     Equality returns Superior
	 *     Equality.Equality_1_0_0_0 returns Superior
	 *     Equality.Inequality_1_0_1_0 returns Superior
	 *     Comparison returns Superior
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Superior
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Superior
	 *     Comparison.Superior_1_0_2_0 returns Superior
	 *     Comparison.Inferior_1_0_3_0 returns Superior
	 *     PlusOrMinus returns Superior
	 *     PlusOrMinus.Plus_1_0_0_0 returns Superior
	 *     PlusOrMinus.Minus_1_0_1_0 returns Superior
	 *     MulOrDiv returns Superior
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Superior
	 *     MulOrDiv.Division_1_0_1_0 returns Superior
	 *     ArrayAccess returns Superior
	 *     ArrayAccess.ArrayAccess_1_0 returns Superior
	 *     ArrayLength returns Superior
	 *     ArrayLength.ArrayLength_1_0 returns Superior
	 *     Primary returns Superior
	 *
	 * Constraint:
	 *     (left=Comparison_Superior_1_0_2_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Superior semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.SUPERIOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.SUPERIOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.SUPERIOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.SUPERIOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getSuperiorLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns SuperiorOrEqual
	 *     Expression returns SuperiorOrEqual
	 *     Or returns SuperiorOrEqual
	 *     Or.Or_1_0 returns SuperiorOrEqual
	 *     And returns SuperiorOrEqual
	 *     And.And_1_0 returns SuperiorOrEqual
	 *     Equality returns SuperiorOrEqual
	 *     Equality.Equality_1_0_0_0 returns SuperiorOrEqual
	 *     Equality.Inequality_1_0_1_0 returns SuperiorOrEqual
	 *     Comparison returns SuperiorOrEqual
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns SuperiorOrEqual
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns SuperiorOrEqual
	 *     Comparison.Superior_1_0_2_0 returns SuperiorOrEqual
	 *     Comparison.Inferior_1_0_3_0 returns SuperiorOrEqual
	 *     PlusOrMinus returns SuperiorOrEqual
	 *     PlusOrMinus.Plus_1_0_0_0 returns SuperiorOrEqual
	 *     PlusOrMinus.Minus_1_0_1_0 returns SuperiorOrEqual
	 *     MulOrDiv returns SuperiorOrEqual
	 *     MulOrDiv.Multiplication_1_0_0_0 returns SuperiorOrEqual
	 *     MulOrDiv.Division_1_0_1_0 returns SuperiorOrEqual
	 *     ArrayAccess returns SuperiorOrEqual
	 *     ArrayAccess.ArrayAccess_1_0 returns SuperiorOrEqual
	 *     ArrayLength returns SuperiorOrEqual
	 *     ArrayLength.ArrayLength_1_0 returns SuperiorOrEqual
	 *     Primary returns SuperiorOrEqual
	 *
	 * Constraint:
	 *     (left=Comparison_SuperiorOrEqual_1_0_0_0 right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, SuperiorOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.SUPERIOR_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.SUPERIOR_OR_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.SUPERIOR_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.SUPERIOR_OR_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getSuperiorOrEqualLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getRightPlusOrMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Equality
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0_0_0 returns Equality
	 *     Equality.Inequality_1_0_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Equality
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Equality
	 *     Comparison.Superior_1_0_2_0 returns Equality
	 *     Comparison.Inferior_1_0_3_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Equality
	 *     MulOrDiv.Division_1_0_1_0 returns Equality
	 *     ArrayAccess returns Equality
	 *     ArrayAccess.ArrayAccess_1_0 returns Equality
	 *     ArrayLength returns Equality
	 *     ArrayLength.ArrayLength_1_0 returns Equality
	 *     Primary returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0_0_0 right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.EQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.EQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Inequality
	 *     Expression returns Inequality
	 *     Or returns Inequality
	 *     Or.Or_1_0 returns Inequality
	 *     And returns Inequality
	 *     And.And_1_0 returns Inequality
	 *     Equality returns Inequality
	 *     Equality.Equality_1_0_0_0 returns Inequality
	 *     Equality.Inequality_1_0_1_0 returns Inequality
	 *     Comparison returns Inequality
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Inequality
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Inequality
	 *     Comparison.Superior_1_0_2_0 returns Inequality
	 *     Comparison.Inferior_1_0_3_0 returns Inequality
	 *     PlusOrMinus returns Inequality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Inequality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Inequality
	 *     MulOrDiv returns Inequality
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Inequality
	 *     MulOrDiv.Division_1_0_1_0 returns Inequality
	 *     ArrayAccess returns Inequality
	 *     ArrayAccess.ArrayAccess_1_0 returns Inequality
	 *     ArrayLength returns Inequality
	 *     ArrayLength.ArrayLength_1_0 returns Inequality
	 *     Primary returns Inequality
	 *
	 * Constraint:
	 *     (left=Equality_Inequality_1_0_1_0 right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Inequality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.INEQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.INEQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.INEQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.INEQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getInequalityLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Field
	 *     Field returns Field
	 *     NamedElement returns Field
	 *     TypedDeclaration returns Field
	 *
	 * Constraint:
	 *     (access=AccessLevel? typeRef=TypeRef name=ID defaultValue=Expression?)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (declaration=Assignment condition=Expression progression=Assignment block=Block)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__DECLARATION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__PROGRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__PROGRESSION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.FOR_STATEMENT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getDeclarationAssignmentParserRuleCall_2_0(), semanticObject.getDeclaration());
		feeder.accept(grammarAccess.getForStatementAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForStatementAccess().getProgressionAssignmentParserRuleCall_6_0(), semanticObject.getProgression());
		feeder.accept(grammarAccess.getForStatementAccess().getBlockBlockParserRuleCall_8_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (expression=Expression thenBlock=Block elseBlock=Block?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns Interface
	 *     Interface returns Interface
	 *     NamedElement returns Interface
	 *
	 * Constraint:
	 *     (accessLevel=AccessLevel? name=ID (implements+=[Interface|QualifiedName] implements+=[Interface|QualifiedName]*)? members+=Member*)
	 */
	protected void sequence_Interface(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Member returns Method
	 *     Method returns Method
	 *     NamedElement returns Method
	 *     TypedDeclaration returns Method
	 *
	 * Constraint:
	 *     (
	 *         access=AccessLevel? 
	 *         abstract?='abstract'? 
	 *         static?='static'? 
	 *         typeRef=TypeRef 
	 *         name=ID? 
	 *         (params+=Parameter params+=Parameter*)? 
	 *         body=Block?
	 *     )
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Division
	 *     Expression returns Division
	 *     Or returns Division
	 *     Or.Or_1_0 returns Division
	 *     And returns Division
	 *     And.And_1_0 returns Division
	 *     Equality returns Division
	 *     Equality.Equality_1_0_0_0 returns Division
	 *     Equality.Inequality_1_0_1_0 returns Division
	 *     Comparison returns Division
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Division
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Division
	 *     Comparison.Superior_1_0_2_0 returns Division
	 *     Comparison.Inferior_1_0_3_0 returns Division
	 *     PlusOrMinus returns Division
	 *     PlusOrMinus.Plus_1_0_0_0 returns Division
	 *     PlusOrMinus.Minus_1_0_1_0 returns Division
	 *     MulOrDiv returns Division
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Division
	 *     MulOrDiv.Division_1_0_1_0 returns Division
	 *     ArrayAccess returns Division
	 *     ArrayAccess.ArrayAccess_1_0 returns Division
	 *     ArrayLength returns Division
	 *     ArrayLength.ArrayLength_1_0 returns Division
	 *     Primary returns Division
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Division_1_0_1_0 right=ArrayAccess)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getDivisionLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightArrayAccessParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Multiplication
	 *     Expression returns Multiplication
	 *     Or returns Multiplication
	 *     Or.Or_1_0 returns Multiplication
	 *     And returns Multiplication
	 *     And.And_1_0 returns Multiplication
	 *     Equality returns Multiplication
	 *     Equality.Equality_1_0_0_0 returns Multiplication
	 *     Equality.Inequality_1_0_1_0 returns Multiplication
	 *     Comparison returns Multiplication
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Multiplication
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Multiplication
	 *     Comparison.Superior_1_0_2_0 returns Multiplication
	 *     Comparison.Inferior_1_0_3_0 returns Multiplication
	 *     PlusOrMinus returns Multiplication
	 *     PlusOrMinus.Plus_1_0_0_0 returns Multiplication
	 *     PlusOrMinus.Minus_1_0_1_0 returns Multiplication
	 *     MulOrDiv returns Multiplication
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Multiplication
	 *     MulOrDiv.Division_1_0_1_0 returns Multiplication
	 *     ArrayAccess returns Multiplication
	 *     ArrayAccess.ArrayAccess_1_0 returns Multiplication
	 *     ArrayLength returns Multiplication
	 *     ArrayLength.ArrayLength_1_0 returns Multiplication
	 *     Primary returns Multiplication
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Multiplication_1_0_0_0 right=ArrayAccess)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getMultiplicationLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightArrayAccessParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Or
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0_0_0 returns Or
	 *     Equality.Inequality_1_0_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Or
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Or
	 *     Comparison.Superior_1_0_2_0 returns Or
	 *     Comparison.Inferior_1_0_3_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Or
	 *     MulOrDiv.Division_1_0_1_0 returns Or
	 *     ArrayAccess returns Or
	 *     ArrayAccess.ArrayAccess_1_0 returns Or
	 *     ArrayLength returns Or
	 *     ArrayLength.ArrayLength_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *     NamedElement returns Parameter
	 *     TypedDeclaration returns Parameter
	 *     Symbol returns Parameter
	 *
	 * Constraint:
	 *     (typeRef=TypeRef name=ID)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.tetrabox.minijava.model.miniJava.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.TYPED_DECLARATION__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.TYPED_DECLARATION__TYPE_REF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getTypeRefTypeRefParserRuleCall_0_0(), semanticObject.getTypeRef());
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Minus
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0_0_0 returns Minus
	 *     Equality.Inequality_1_0_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Minus
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Minus
	 *     Comparison.Superior_1_0_2_0 returns Minus
	 *     Comparison.Inferior_1_0_3_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Minus
	 *     MulOrDiv.Division_1_0_1_0 returns Minus
	 *     ArrayAccess returns Minus
	 *     ArrayAccess.ArrayAccess_1_0 returns Minus
	 *     ArrayLength returns Minus
	 *     ArrayLength.ArrayLength_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Plus
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0_0_0 returns Plus
	 *     Equality.Inequality_1_0_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Plus
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Plus
	 *     Comparison.Superior_1_0_2_0 returns Plus
	 *     Comparison.Inferior_1_0_3_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Plus
	 *     MulOrDiv.Division_1_0_1_0 returns Plus
	 *     ArrayAccess returns Plus
	 *     ArrayAccess.ArrayAccess_1_0 returns Plus
	 *     ArrayLength returns Plus
	 *     ArrayLength.ArrayLength_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Neg
	 *     Expression returns Neg
	 *     Or returns Neg
	 *     Or.Or_1_0 returns Neg
	 *     And returns Neg
	 *     And.And_1_0 returns Neg
	 *     Equality returns Neg
	 *     Equality.Equality_1_0_0_0 returns Neg
	 *     Equality.Inequality_1_0_1_0 returns Neg
	 *     Comparison returns Neg
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Neg
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Neg
	 *     Comparison.Superior_1_0_2_0 returns Neg
	 *     Comparison.Inferior_1_0_3_0 returns Neg
	 *     PlusOrMinus returns Neg
	 *     PlusOrMinus.Plus_1_0_0_0 returns Neg
	 *     PlusOrMinus.Minus_1_0_1_0 returns Neg
	 *     MulOrDiv returns Neg
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Neg
	 *     MulOrDiv.Division_1_0_1_0 returns Neg
	 *     ArrayAccess returns Neg
	 *     ArrayAccess.ArrayAccess_1_0 returns Neg
	 *     ArrayLength returns Neg
	 *     ArrayLength.ArrayLength_1_0 returns Neg
	 *     Primary returns Neg
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Neg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.NEG__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.NEG__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignee returns Not
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0_0_0 returns Not
	 *     Equality.Inequality_1_0_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Not
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Not
	 *     Comparison.Superior_1_0_2_0 returns Not
	 *     Comparison.Inferior_1_0_3_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Not
	 *     MulOrDiv.Division_1_0_1_0 returns Not
	 *     ArrayAccess returns Not
	 *     ArrayAccess.ArrayAccess_1_0 returns Not
	 *     ArrayLength returns Not
	 *     ArrayLength.ArrayLength_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PrintStatement
	 *     PrintStatement returns PrintStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_PrintStatement(ISerializationContext context, PrintStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.PRINT_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.PRINT_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintStatementAccess().getExpressionExpressionParserRuleCall_6_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     ((name=QualifiedName? imports+=Import+ classes+=TypeDeclaration+) | (name=QualifiedName? classes+=TypeDeclaration+) | classes+=TypeDeclaration+)?
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.RETURN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns FieldAccess
	 *     Assignee returns FieldAccess
	 *     Expression returns FieldAccess
	 *     Or returns FieldAccess
	 *     Or.Or_1_0 returns FieldAccess
	 *     And returns FieldAccess
	 *     And.And_1_0 returns FieldAccess
	 *     Equality returns FieldAccess
	 *     Equality.Equality_1_0_0_0 returns FieldAccess
	 *     Equality.Inequality_1_0_1_0 returns FieldAccess
	 *     Comparison returns FieldAccess
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns FieldAccess
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns FieldAccess
	 *     Comparison.Superior_1_0_2_0 returns FieldAccess
	 *     Comparison.Inferior_1_0_3_0 returns FieldAccess
	 *     PlusOrMinus returns FieldAccess
	 *     PlusOrMinus.Plus_1_0_0_0 returns FieldAccess
	 *     PlusOrMinus.Minus_1_0_1_0 returns FieldAccess
	 *     MulOrDiv returns FieldAccess
	 *     MulOrDiv.Multiplication_1_0_0_0 returns FieldAccess
	 *     MulOrDiv.Division_1_0_1_0 returns FieldAccess
	 *     ArrayAccess returns FieldAccess
	 *     ArrayAccess.ArrayAccess_1_0 returns FieldAccess
	 *     ArrayLength returns FieldAccess
	 *     ArrayLength.ArrayLength_1_0 returns FieldAccess
	 *     Primary returns FieldAccess
	 *     SelectionExpression returns FieldAccess
	 *     SelectionExpression.FieldAccess_1_0_0 returns FieldAccess
	 *     SelectionExpression.MethodCall_1_1_0 returns FieldAccess
	 *
	 * Constraint:
	 *     (receiver=SelectionExpression_FieldAccess_1_0_0 field=[Field|ID])
	 */
	protected void sequence_SelectionExpression(ISerializationContext context, FieldAccess semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.FIELD_ACCESS__RECEIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.FIELD_ACCESS__RECEIVER));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.FIELD_ACCESS__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.FIELD_ACCESS__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectionExpressionAccess().getFieldAccessReceiverAction_1_0_0(), semanticObject.getReceiver());
		feeder.accept(grammarAccess.getSelectionExpressionAccess().getFieldFieldIDTerminalRuleCall_1_0_2_0_1(), semanticObject.eGet(MiniJavaPackage.Literals.FIELD_ACCESS__FIELD, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MethodCall
	 *     Assignee returns MethodCall
	 *     Expression returns MethodCall
	 *     Or returns MethodCall
	 *     Or.Or_1_0 returns MethodCall
	 *     And returns MethodCall
	 *     And.And_1_0 returns MethodCall
	 *     Equality returns MethodCall
	 *     Equality.Equality_1_0_0_0 returns MethodCall
	 *     Equality.Inequality_1_0_1_0 returns MethodCall
	 *     Comparison returns MethodCall
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns MethodCall
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns MethodCall
	 *     Comparison.Superior_1_0_2_0 returns MethodCall
	 *     Comparison.Inferior_1_0_3_0 returns MethodCall
	 *     PlusOrMinus returns MethodCall
	 *     PlusOrMinus.Plus_1_0_0_0 returns MethodCall
	 *     PlusOrMinus.Minus_1_0_1_0 returns MethodCall
	 *     MulOrDiv returns MethodCall
	 *     MulOrDiv.Multiplication_1_0_0_0 returns MethodCall
	 *     MulOrDiv.Division_1_0_1_0 returns MethodCall
	 *     ArrayAccess returns MethodCall
	 *     ArrayAccess.ArrayAccess_1_0 returns MethodCall
	 *     ArrayLength returns MethodCall
	 *     ArrayLength.ArrayLength_1_0 returns MethodCall
	 *     Primary returns MethodCall
	 *     SelectionExpression returns MethodCall
	 *     SelectionExpression.FieldAccess_1_0_0 returns MethodCall
	 *     SelectionExpression.MethodCall_1_1_0 returns MethodCall
	 *
	 * Constraint:
	 *     (receiver=SelectionExpression_MethodCall_1_1_0 method=[Method|ID] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_SelectionExpression(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns BooleanTypeRef
	 *     TypeRef.ArrayTypeRef_1_0 returns BooleanTypeRef
	 *     SingleTypeRef returns BooleanTypeRef
	 *
	 * Constraint:
	 *     {BooleanTypeRef}
	 */
	protected void sequence_SingleTypeRef(ISerializationContext context, BooleanTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns IntegerTypeRef
	 *     TypeRef.ArrayTypeRef_1_0 returns IntegerTypeRef
	 *     SingleTypeRef returns IntegerTypeRef
	 *
	 * Constraint:
	 *     {IntegerTypeRef}
	 */
	protected void sequence_SingleTypeRef(ISerializationContext context, IntegerTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns StringTypeRef
	 *     TypeRef.ArrayTypeRef_1_0 returns StringTypeRef
	 *     SingleTypeRef returns StringTypeRef
	 *
	 * Constraint:
	 *     {StringTypeRef}
	 */
	protected void sequence_SingleTypeRef(ISerializationContext context, StringTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns VoidTypeRef
	 *     TypeRef.ArrayTypeRef_1_0 returns VoidTypeRef
	 *     SingleTypeRef returns VoidTypeRef
	 *
	 * Constraint:
	 *     {VoidTypeRef}
	 */
	protected void sequence_SingleTypeRef(ISerializationContext context, VoidTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BoolConstant
	 *     Assignee returns BoolConstant
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0_0_0 returns BoolConstant
	 *     Equality.Inequality_1_0_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns BoolConstant
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns BoolConstant
	 *     Comparison.Superior_1_0_2_0 returns BoolConstant
	 *     Comparison.Inferior_1_0_3_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.Multiplication_1_0_0_0 returns BoolConstant
	 *     MulOrDiv.Division_1_0_1_0 returns BoolConstant
	 *     ArrayAccess returns BoolConstant
	 *     ArrayAccess.ArrayAccess_1_0 returns BoolConstant
	 *     ArrayLength returns BoolConstant
	 *     ArrayLength.ArrayLength_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     SelectionExpression returns BoolConstant
	 *     SelectionExpression.FieldAccess_1_0_0 returns BoolConstant
	 *     SelectionExpression.MethodCall_1_1_0 returns BoolConstant
	 *     TerminalExpression returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntConstant
	 *     Assignee returns IntConstant
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0_0_0 returns IntConstant
	 *     Equality.Inequality_1_0_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns IntConstant
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns IntConstant
	 *     Comparison.Superior_1_0_2_0 returns IntConstant
	 *     Comparison.Inferior_1_0_3_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.Multiplication_1_0_0_0 returns IntConstant
	 *     MulOrDiv.Division_1_0_1_0 returns IntConstant
	 *     ArrayAccess returns IntConstant
	 *     ArrayAccess.ArrayAccess_1_0 returns IntConstant
	 *     ArrayLength returns IntConstant
	 *     ArrayLength.ArrayLength_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     SelectionExpression returns IntConstant
	 *     SelectionExpression.FieldAccess_1_0_0 returns IntConstant
	 *     SelectionExpression.MethodCall_1_1_0 returns IntConstant
	 *     TerminalExpression returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NewArray
	 *     Assignee returns NewArray
	 *     Expression returns NewArray
	 *     Or returns NewArray
	 *     Or.Or_1_0 returns NewArray
	 *     And returns NewArray
	 *     And.And_1_0 returns NewArray
	 *     Equality returns NewArray
	 *     Equality.Equality_1_0_0_0 returns NewArray
	 *     Equality.Inequality_1_0_1_0 returns NewArray
	 *     Comparison returns NewArray
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns NewArray
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns NewArray
	 *     Comparison.Superior_1_0_2_0 returns NewArray
	 *     Comparison.Inferior_1_0_3_0 returns NewArray
	 *     PlusOrMinus returns NewArray
	 *     PlusOrMinus.Plus_1_0_0_0 returns NewArray
	 *     PlusOrMinus.Minus_1_0_1_0 returns NewArray
	 *     MulOrDiv returns NewArray
	 *     MulOrDiv.Multiplication_1_0_0_0 returns NewArray
	 *     MulOrDiv.Division_1_0_1_0 returns NewArray
	 *     ArrayAccess returns NewArray
	 *     ArrayAccess.ArrayAccess_1_0 returns NewArray
	 *     ArrayLength returns NewArray
	 *     ArrayLength.ArrayLength_1_0 returns NewArray
	 *     Primary returns NewArray
	 *     SelectionExpression returns NewArray
	 *     SelectionExpression.FieldAccess_1_0_0 returns NewArray
	 *     SelectionExpression.MethodCall_1_1_0 returns NewArray
	 *     TerminalExpression returns NewArray
	 *
	 * Constraint:
	 *     (type=TypeRef size=Expression)
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, NewArray semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.NEW_ARRAY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.NEW_ARRAY__TYPE));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.NEW_ARRAY__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.NEW_ARRAY__SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getTypeTypeRefParserRuleCall_7_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getSizeExpressionParserRuleCall_7_4_0(), semanticObject.getSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns NewObject
	 *     Assignee returns NewObject
	 *     Expression returns NewObject
	 *     Or returns NewObject
	 *     Or.Or_1_0 returns NewObject
	 *     And returns NewObject
	 *     And.And_1_0 returns NewObject
	 *     Equality returns NewObject
	 *     Equality.Equality_1_0_0_0 returns NewObject
	 *     Equality.Inequality_1_0_1_0 returns NewObject
	 *     Comparison returns NewObject
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns NewObject
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns NewObject
	 *     Comparison.Superior_1_0_2_0 returns NewObject
	 *     Comparison.Inferior_1_0_3_0 returns NewObject
	 *     PlusOrMinus returns NewObject
	 *     PlusOrMinus.Plus_1_0_0_0 returns NewObject
	 *     PlusOrMinus.Minus_1_0_1_0 returns NewObject
	 *     MulOrDiv returns NewObject
	 *     MulOrDiv.Multiplication_1_0_0_0 returns NewObject
	 *     MulOrDiv.Division_1_0_1_0 returns NewObject
	 *     ArrayAccess returns NewObject
	 *     ArrayAccess.ArrayAccess_1_0 returns NewObject
	 *     ArrayLength returns NewObject
	 *     ArrayLength.ArrayLength_1_0 returns NewObject
	 *     Primary returns NewObject
	 *     SelectionExpression returns NewObject
	 *     SelectionExpression.FieldAccess_1_0_0 returns NewObject
	 *     SelectionExpression.MethodCall_1_1_0 returns NewObject
	 *     TerminalExpression returns NewObject
	 *
	 * Constraint:
	 *     (type=[Class|ID] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, NewObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Null
	 *     Assignee returns Null
	 *     Expression returns Null
	 *     Or returns Null
	 *     Or.Or_1_0 returns Null
	 *     And returns Null
	 *     And.And_1_0 returns Null
	 *     Equality returns Null
	 *     Equality.Equality_1_0_0_0 returns Null
	 *     Equality.Inequality_1_0_1_0 returns Null
	 *     Comparison returns Null
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Null
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Null
	 *     Comparison.Superior_1_0_2_0 returns Null
	 *     Comparison.Inferior_1_0_3_0 returns Null
	 *     PlusOrMinus returns Null
	 *     PlusOrMinus.Plus_1_0_0_0 returns Null
	 *     PlusOrMinus.Minus_1_0_1_0 returns Null
	 *     MulOrDiv returns Null
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Null
	 *     MulOrDiv.Division_1_0_1_0 returns Null
	 *     ArrayAccess returns Null
	 *     ArrayAccess.ArrayAccess_1_0 returns Null
	 *     ArrayLength returns Null
	 *     ArrayLength.ArrayLength_1_0 returns Null
	 *     Primary returns Null
	 *     SelectionExpression returns Null
	 *     SelectionExpression.FieldAccess_1_0_0 returns Null
	 *     SelectionExpression.MethodCall_1_1_0 returns Null
	 *     TerminalExpression returns Null
	 *
	 * Constraint:
	 *     {Null}
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, Null semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StringConstant
	 *     Assignee returns StringConstant
	 *     Expression returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0_0_0 returns StringConstant
	 *     Equality.Inequality_1_0_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns StringConstant
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns StringConstant
	 *     Comparison.Superior_1_0_2_0 returns StringConstant
	 *     Comparison.Inferior_1_0_3_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.Multiplication_1_0_0_0 returns StringConstant
	 *     MulOrDiv.Division_1_0_1_0 returns StringConstant
	 *     ArrayAccess returns StringConstant
	 *     ArrayAccess.ArrayAccess_1_0 returns StringConstant
	 *     ArrayLength returns StringConstant
	 *     ArrayLength.ArrayLength_1_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     SelectionExpression returns StringConstant
	 *     SelectionExpression.FieldAccess_1_0_0 returns StringConstant
	 *     SelectionExpression.MethodCall_1_1_0 returns StringConstant
	 *     TerminalExpression returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Super
	 *     Assignee returns Super
	 *     Expression returns Super
	 *     Or returns Super
	 *     Or.Or_1_0 returns Super
	 *     And returns Super
	 *     And.And_1_0 returns Super
	 *     Equality returns Super
	 *     Equality.Equality_1_0_0_0 returns Super
	 *     Equality.Inequality_1_0_1_0 returns Super
	 *     Comparison returns Super
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns Super
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns Super
	 *     Comparison.Superior_1_0_2_0 returns Super
	 *     Comparison.Inferior_1_0_3_0 returns Super
	 *     PlusOrMinus returns Super
	 *     PlusOrMinus.Plus_1_0_0_0 returns Super
	 *     PlusOrMinus.Minus_1_0_1_0 returns Super
	 *     MulOrDiv returns Super
	 *     MulOrDiv.Multiplication_1_0_0_0 returns Super
	 *     MulOrDiv.Division_1_0_1_0 returns Super
	 *     ArrayAccess returns Super
	 *     ArrayAccess.ArrayAccess_1_0 returns Super
	 *     ArrayLength returns Super
	 *     ArrayLength.ArrayLength_1_0 returns Super
	 *     Primary returns Super
	 *     SelectionExpression returns Super
	 *     SelectionExpression.FieldAccess_1_0_0 returns Super
	 *     SelectionExpression.MethodCall_1_1_0 returns Super
	 *     TerminalExpression returns Super
	 *
	 * Constraint:
	 *     {Super}
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, Super semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SymbolRef
	 *     Assignee returns SymbolRef
	 *     Expression returns SymbolRef
	 *     Or returns SymbolRef
	 *     Or.Or_1_0 returns SymbolRef
	 *     And returns SymbolRef
	 *     And.And_1_0 returns SymbolRef
	 *     Equality returns SymbolRef
	 *     Equality.Equality_1_0_0_0 returns SymbolRef
	 *     Equality.Inequality_1_0_1_0 returns SymbolRef
	 *     Comparison returns SymbolRef
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns SymbolRef
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns SymbolRef
	 *     Comparison.Superior_1_0_2_0 returns SymbolRef
	 *     Comparison.Inferior_1_0_3_0 returns SymbolRef
	 *     PlusOrMinus returns SymbolRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns SymbolRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns SymbolRef
	 *     MulOrDiv returns SymbolRef
	 *     MulOrDiv.Multiplication_1_0_0_0 returns SymbolRef
	 *     MulOrDiv.Division_1_0_1_0 returns SymbolRef
	 *     ArrayAccess returns SymbolRef
	 *     ArrayAccess.ArrayAccess_1_0 returns SymbolRef
	 *     ArrayLength returns SymbolRef
	 *     ArrayLength.ArrayLength_1_0 returns SymbolRef
	 *     Primary returns SymbolRef
	 *     SelectionExpression returns SymbolRef
	 *     SelectionExpression.FieldAccess_1_0_0 returns SymbolRef
	 *     SelectionExpression.MethodCall_1_1_0 returns SymbolRef
	 *     TerminalExpression returns SymbolRef
	 *
	 * Constraint:
	 *     symbol=[Symbol|ID]
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, SymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.SYMBOL_REF__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.SYMBOL_REF__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalExpressionAccess().getSymbolSymbolIDTerminalRuleCall_8_1_0_1(), semanticObject.eGet(MiniJavaPackage.Literals.SYMBOL_REF__SYMBOL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns This
	 *     Assignee returns This
	 *     Expression returns This
	 *     Or returns This
	 *     Or.Or_1_0 returns This
	 *     And returns This
	 *     And.And_1_0 returns This
	 *     Equality returns This
	 *     Equality.Equality_1_0_0_0 returns This
	 *     Equality.Inequality_1_0_1_0 returns This
	 *     Comparison returns This
	 *     Comparison.SuperiorOrEqual_1_0_0_0 returns This
	 *     Comparison.InferiorOrEqual_1_0_1_0 returns This
	 *     Comparison.Superior_1_0_2_0 returns This
	 *     Comparison.Inferior_1_0_3_0 returns This
	 *     PlusOrMinus returns This
	 *     PlusOrMinus.Plus_1_0_0_0 returns This
	 *     PlusOrMinus.Minus_1_0_1_0 returns This
	 *     MulOrDiv returns This
	 *     MulOrDiv.Multiplication_1_0_0_0 returns This
	 *     MulOrDiv.Division_1_0_1_0 returns This
	 *     ArrayAccess returns This
	 *     ArrayAccess.ArrayAccess_1_0 returns This
	 *     ArrayLength returns This
	 *     ArrayLength.ArrayLength_1_0 returns This
	 *     Primary returns This
	 *     SelectionExpression returns This
	 *     SelectionExpression.FieldAccess_1_0_0 returns This
	 *     SelectionExpression.MethodCall_1_1_0 returns This
	 *     TerminalExpression returns This
	 *
	 * Constraint:
	 *     {This}
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns ArrayTypeRef
	 *
	 * Constraint:
	 *     typeRef=TypeRef_ArrayTypeRef_1_0
	 */
	protected void sequence_TypeRef(ISerializationContext context, ArrayTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.ARRAY_TYPE_REF__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.ARRAY_TYPE_REF__TYPE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeRefAccess().getArrayTypeRefTypeRefAction_1_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedElement returns VariableDeclaration
	 *     TypedDeclaration returns VariableDeclaration
	 *     Symbol returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *     Assignee returns VariableDeclaration
	 *
	 * Constraint:
	 *     (typeRef=TypeRef name=ID)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.TYPED_DECLARATION__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.TYPED_DECLARATION__TYPE_REF));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeRefTypeRefParserRuleCall_0_0(), semanticObject.getTypeRef());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression block=Block)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MiniJavaPackage.Literals.WHILE_STATEMENT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniJavaPackage.Literals.WHILE_STATEMENT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBlockBlockParserRuleCall_4_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
}
